//! A slotvec, a vector-like container with unique indices.
//!
//! See the documentation of [`SlotVec`] for details.
//!
//! [`SlotVec`]: struct.SlotVec.html
use core::ops::{Index, IndexMut};

use super::ManagedSlice as Slice;

/// Provides a slotvec based on external memory.
///
/// Provides mappings between slots and elements.
///
/// A slotvec provides a vector(`Vec`)-like interface where each entry is
/// associated with a stable index. Lookup with the index will detect if
/// an entry has been removed but does not require a lifetime relation.
/// It will allocate memory internally when adding elements to slotvec
/// if the [`Slice`] argument to the constructor is a [`Slice::Owned`] Vec.
/// It only replaces the Option element value with the value that actually
/// if the [`Slice`] argument to the constructor is a [`Slice::Borrowed`] slice.
#[derive(Debug)]
pub struct SlotVec<'a, T> {
    /// An element: Option\<T\> represents:
    /// - index -> Some(T) => There is a valid value<T> at index.
    /// - index -> None => There is no or a freed value at index.
    slice: Slice<'a, Option<T>>,
    /// The forward valid free slice index.
    free_top_index: Option<usize>,
}

impl<'a, T> SlotVec<'a, T> {
    fn next_free_top_index(&mut self, skip_count: usize) {
        for (index, slot) in self.slice.iter().enumerate().skip(skip_count) {
            if slot.is_none() {
                self.free_top_index.replace(index);
                return; // break loop if next found
            }
        }
    }
}

impl<'a, T> SlotVec<'a, T> {
    /// Creates a slot vec, `Option` is used to mark whether the slot has been used.
    pub fn new(slice: Slice<'a, Option<T>>) -> Self {
        let mut slot_vec = Self {
            slice,
            free_top_index: None,
        };
        slot_vec.next_free_top_index(0);
        slot_vec
    }

    /// Pushes an element to the back of the slice in the vec,
    /// an element should be generated by the function `elem_fn` calling.
    ///
    /// Returns None if the slice is fixed-size (not a owned `Vec`) and is full.
    #[inline]
    pub fn push_with(&mut self, elem_fn: impl FnOnce(usize) -> T) -> Option<usize> {
        // The removed elements will always be queried by this logic,
        // because free_top_index is always set in the remove function.
        if let Some(index) = self.free_top_index.take() {
            self.slice[index].replace(elem_fn(index));
            // Since none of the element slots before free_top_index are available,
            // we simply think the next free top start from the free_top_index next.
            self.next_free_top_index(index + 1);
            return Some(index);
        }
        // If no element has been removed, the following code logic
        // will always be executed, possibly new allocating on owned.
        match &mut self.slice {
            Slice::Borrowed(_) => None,
            #[cfg(any(feature = "std", feature = "alloc"))]
            Slice::Owned(slice) => {
                slice.push(None); // placeholder
                let index = slice.len() - 1;
                // don't do this set because we can't know
                // for sure it will be indexed successfully.
                // self.free_top_index.replace(slice.len());
                self.slice[index].replace(elem_fn(index));
                Some(index)
            }
        }
    }

    /// Pushes an element to the back in the vec.
    ///
    /// Returns None if the slice is fixed-size (not a `Vec`) and is full.
    pub fn push(&mut self, elem: T) -> Option<usize> {
        self.push_with(|_| elem)
    }

    /// Gets an element from the vec by its index, as immutable.
    ///
    /// Returns `None` if the index did not refer to a valid element.
    pub fn get(&self, index: usize) -> Option<&T> {
        self.slice.get(index)?.as_ref()
    }

    /// Gets an element from the vec by its index, as mutable.
    ///
    /// Returns `None` if the index did not refer to a valid element.
    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {
        self.slice.get_mut(index)?.as_mut()
    }

    /// Removes an element from the vec, without changing it.
    ///
    /// Returns the removed element that could be freed if successful,
    /// returns `None` if the index did not refer to a valid element.
    pub fn remove(&mut self, index: usize) -> Option<T> {
        let removed = self.slice.get_mut(index)?.take()?;
        self.free_top_index = match self.free_top_index {
            Some(old_index) if index < old_index => Some(index),
            Some(old_index) => Some(old_index),
            None => Some(index),
        };
        Some(removed)
    }

    /// Returns the number of valid elements in the vec.
    pub fn len(&self) -> usize {
        self.iter().count()
    }

    /// Returns true if the vec contains no valid elements.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Iterates every element of this vec, as immutable.
    pub fn iter<'s>(&'s self) -> impl DoubleEndedIterator<Item = &'s T> {
        self.slice.iter().filter_map(|slot| slot.as_ref())
    }

    /// Iterates every element of this vec, as mutable.
    pub fn iter_mut<'s>(&'s mut self) -> impl DoubleEndedIterator<Item = &'s mut T> {
        self.slice.iter_mut().filter_map(|slot| slot.as_mut())
    }
}

impl<'a, T> Index<usize> for SlotVec<'a, T> {
    type Output = T;

    /// Returns a immutable reference to the value corresponding to the supplied index.
    ///
    /// # Panics
    ///
    /// Panics if the index is not present in the `SlotVec`.
    fn index(&self, index: usize) -> &Self::Output {
        self.get(index).unwrap()
    }
}

impl<'a, T> IndexMut<usize> for SlotVec<'a, T> {
    /// Returns a mutable reference to the value corresponding to the supplied index.
    ///
    /// # Panics
    ///
    /// Panics if the index is not present in the `SlotVec`.
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        self.get_mut(index).unwrap()
    }
}

#[cfg(test)]
mod tests {
    use super::{Slice, SlotVec};
    use std::{
        format,
        string::{String, ToString},
        vec,
        vec::Vec,
    };

    #[test]
    fn simple() {
        let mut slot_vec: SlotVec<&str> = SlotVec::new(Slice::Owned(vec![]));

        let index = slot_vec.push("hello").unwrap();
        assert_eq!(slot_vec.get(index), Some(&"hello"));
        assert_eq!(slot_vec[index], "hello");
        let index = slot_vec.push("world").unwrap();
        assert_eq!(slot_vec.get(index), Some(&"world"));
        assert_eq!(slot_vec[index], "world");

        assert_eq!(
            slot_vec.iter().collect::<Vec<&&str>>(),
            [&"hello", &"world"]
        );
    }

    #[test]
    fn retained() {
        let mut slot_vec: SlotVec<&str> = SlotVec::new(Slice::Owned(vec![]));

        let idx1 = slot_vec.push("hello").unwrap();
        let idx2 = slot_vec.push("world").unwrap();
        let idx3 = slot_vec.push("jacky").unwrap();

        assert_eq!(slot_vec.remove(idx1), Some("hello"));
        assert_eq!(slot_vec.get(idx1), None);
        // nonexistent index, panics
        // slot_vec[idx1];

        assert_eq!(slot_vec.remove(idx3), Some("jacky"));
        assert_eq!(slot_vec.get(idx3), None);

        assert_eq!(slot_vec.iter().count(), 1);

        assert_eq!(slot_vec.remove(idx2), Some("world"));
        assert_eq!(slot_vec.get(idx2), None);
        assert_eq!(slot_vec.iter().count(), 0);

        // The free top index is the one with the smallest index in the deletion.
        assert_eq!(slot_vec.free_top_index, Some(idx1));

        let idx4 = slot_vec.push("small").unwrap();
        assert_eq!(slot_vec.get(idx4), Some(&"small"));
        assert_eq!(slot_vec.iter().count(), 1);

        // The last push will be placed at idx1 in the slotvec, because idx1 is removed,
        // and the free top becomes the one with the smallest deleted index, which is idx2.
        assert_eq!(idx1, idx4);
        assert_eq!(slot_vec.free_top_index, Some(idx2));
    }

    #[test]
    fn complex() {
        let slice = &mut [Default::default(); 1];
        let mut slot_vec: SlotVec<String> = SlotVec::new(Slice::Borrowed(slice));

        let index = slot_vec.push("hello".to_string()).unwrap();
        assert_eq!(slot_vec.get(index).map(|x| x.as_str()), Some("hello"));

        let elem = slot_vec.get_mut(index).unwrap();
        *elem = "world".to_string();
        assert_eq!(slot_vec.get(index).map(|x| x.as_str()), Some("world"));

        // the front slice is full, the length of the front slice borrowed is 1.
        assert_eq!(slot_vec.push("messy".to_string()), None);

        let slice = vec![Default::default(); 2];
        let mut slot_vec: SlotVec<String> = SlotVec::new(Slice::Owned(slice));

        let index = slot_vec.push("hello".to_string()).unwrap();
        assert_eq!(slot_vec.get(index).map(|x| x.as_str()), Some("hello"));

        let index = slot_vec.push("jacky".to_string()).unwrap();
        assert_eq!(slot_vec.get(index).map(|x| x.as_str()), Some("jacky"));

        // Even though the back slice is 2 in length,
        // it can still be pushed because it is an owned vector.
        let index = slot_vec
            .push_with(|index| format!("custom element with index {}", index))
            .unwrap();
        let custom = format!("custom element with index {}", index);

        assert_eq!(
            slot_vec.iter().collect::<Vec<&String>>(),
            [&"hello", &"jacky", &custom.as_str()]
        );
    }
}
